; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	c:\hub\sha3\keccak\k1600.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_rc
EXTRN	__allshl:PROC
; Function compile flags: /Ogspy
; File c:\hub\sha3\keccak\k1600.c
;	COMDAT _rc
_TEXT	SEGMENT
_c$ = -8						; size = 8
_LFSR$ = 8						; size = 4
_rc	PROC						; COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ecx

; 36   :   uint64_t c;
; 37   :   uint32_t i, t;
; 38   : 
; 39   :   c = 0;

	and	DWORD PTR _c$[ebp], 0
	and	DWORD PTR _c$[ebp+4], 0
	push	ebx
	push	esi
	push	edi

; 40   :   t = *LFSR;

	mov	edi, DWORD PTR _LFSR$[ebp]
	movzx	ebx, BYTE PTR [edi]

; 41   :   
; 42   :   for (i=1; i<128; i += i) 

	xor	esi, esi
	inc	esi
$LL11@rc:

; 43   :   {
; 44   :     if (t & 1) {

	test	bl, 1
	je	SHORT $LN1@rc

; 45   :       c ^= (uint64_t)1ULL << (i - 1);

	xor	eax, eax
	lea	ecx, DWORD PTR [esi-1]
	inc	eax
	xor	edx, edx
	call	__allshl
	xor	DWORD PTR _c$[ebp], eax
	xor	DWORD PTR _c$[ebp+4], edx
$LN1@rc:

; 46   :     }
; 47   :     t = (t & 0x80) ? (t << 1) ^ 0x71 : t << 1;

	test	bl, bl
	jns	SHORT $LN7@rc
	add	ebx, ebx
	xor	ebx, 113				; 00000071H
	jmp	SHORT $LN8@rc
$LN7@rc:
	add	ebx, ebx
$LN8@rc:

; 41   :   
; 42   :   for (i=1; i<128; i += i) 

	add	esi, esi
	cmp	esi, 128				; 00000080H
	jb	SHORT $LL11@rc

; 48   :   }
; 49   :   *LFSR = (uint8_t)t;
; 50   :   return c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _c$[ebp+4]
	mov	BYTE PTR [edi], bl
	pop	edi
	pop	esi
	pop	ebx

; 51   : }

	leave
	ret	0
_rc	ENDP
_TEXT	ENDS
PUBLIC	_k1600_permute
EXTRN	__aullshr:PROC
; Function compile flags: /Ogspy
;	COMDAT _k1600_permute
_TEXT	SEGMENT
_bc$ = -108						; size = 40
_keccakf_piln$ = -68					; size = 24
_keccakf_mod5$ = -44					; size = 10
_t$ = -32						; size = 8
tv1185 = -24						; size = 4
tv1187 = -20						; size = 4
_r$ = -16						; size = 4
tv1283 = -12						; size = 4
tv1236 = -8						; size = 4
tv881 = -8						; size = 4
_i$ = -8						; size = 4
_lfsr$ = -1						; size = 1
_state$ = 8						; size = 4
_k1600_permute PROC					; COMDAT

; 54   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx

; 55   :   uint32_t i, j, rnd, r;
; 56   :   uint64_t t, bc[5];
; 57   :   uint8_t  lfsr=1;
; 58   :   uint64_t *st=(uint64_t*)state;
; 59   :   
; 60   : const uint8_t keccakf_piln[24] = 
; 61   : { 10, 7,  11, 17, 18, 3, 5,  16, 8,  21, 24, 4, 
; 62   :   15, 23, 19, 13, 12, 2, 20, 14, 22, 9,  6,  1  };
; 63   :   
; 64   : const uint8_t keccakf_mod5[10] = 
; 65   : { 0, 1, 2, 3, 4, 0, 1, 2, 3, 4 };

	mov	ebx, DWORD PTR _state$[ebp]
	push	esi
	push	edi
	mov	BYTE PTR _lfsr$[ebp], 1
	mov	DWORD PTR _keccakf_piln$[ebp], 285935370 ; 110b070aH
	mov	DWORD PTR _keccakf_piln$[ebp+4], 268763922 ; 10050312H
	mov	DWORD PTR _keccakf_piln$[ebp+8], 68687112 ; 04181508H
	mov	DWORD PTR _keccakf_piln$[ebp+12], 219354895 ; 0d13170fH
	mov	DWORD PTR _keccakf_piln$[ebp+16], 236192268 ; 0e14020cH
	mov	DWORD PTR _keccakf_piln$[ebp+20], 17172758 ; 01060916H
	mov	DWORD PTR _keccakf_mod5$[ebp], 50462976	; 03020100H
	mov	DWORD PTR _keccakf_mod5$[ebp+4], 33619972 ; 02010004H
	mov	WORD PTR _keccakf_mod5$[ebp+8], 1027	; 00000403H
	mov	DWORD PTR tv1283[ebp], 24		; 00000018H
$LL24@k1600_perm:

; 66   :   
; 67   :   for (rnd=0; rnd<24; rnd++) 
; 68   :   {
; 69   :     // Theta
; 70   :     for (i=0; i<5; i++) {     

	xor	ecx, ecx
	lea	eax, DWORD PTR [ebx+120]
$LL21@k1600_perm:

; 71   :       bc[i] = st[i] 
; 72   :             ^ st[i +  5] 
; 73   :             ^ st[i + 10] 
; 74   :             ^ st[i + 15] 
; 75   :             ^ st[i + 20];

	mov	edx, DWORD PTR [eax-120]
	xor	edx, DWORD PTR [eax-80]
	mov	esi, DWORD PTR [eax-116]
	xor	esi, DWORD PTR [eax-76]
	xor	edx, DWORD PTR [eax-40]
	xor	esi, DWORD PTR [eax-36]
	xor	edx, DWORD PTR [eax+40]
	xor	esi, DWORD PTR [eax+44]
	xor	edx, DWORD PTR [eax]
	xor	esi, DWORD PTR [eax+4]
	mov	DWORD PTR _bc$[ebp+ecx*8], edx
	mov	DWORD PTR _bc$[ebp+ecx*8+4], esi
	inc	ecx
	add	eax, 8
	cmp	ecx, 5
	jb	SHORT $LL21@k1600_perm

; 76   :     }
; 77   :     for (i=0; i<5; i++) {

	xor	edi, edi
	mov	DWORD PTR tv881[ebp], ebx
$LL18@k1600_perm:

; 78   :       t = bc[keccakf_mod5[(i + 4)]] ^ ROTL64(bc[keccakf_mod5[(i + 1)]], 1);

	movzx	ecx, BYTE PTR _keccakf_mod5$[ebp+edi+1]
	mov	eax, DWORD PTR _bc$[ebp+ecx*8]
	mov	esi, DWORD PTR _bc$[ebp+ecx*8+4]
	mov	ecx, esi
	shld	esi, eax, 1
	add	eax, eax
	shr	ecx, 31					; 0000001fH
	or	ecx, eax
	movzx	eax, BYTE PTR _keccakf_mod5$[ebp+edi+4]
	xor	ecx, DWORD PTR _bc$[ebp+eax*8]
	xor	edx, edx
	or	edx, esi
	xor	edx, DWORD PTR _bc$[ebp+eax*8+4]
	mov	eax, DWORD PTR tv881[ebp]
	push	5
	pop	esi
$LL15@k1600_perm:

; 79   :       for (j=0; j<25; j+=5) {
; 80   :         st[j + i] ^= t;

	xor	DWORD PTR [eax], ecx
	xor	DWORD PTR [eax+4], edx
	add	eax, 40					; 00000028H
	dec	esi
	jne	SHORT $LL15@k1600_perm

; 76   :     }
; 77   :     for (i=0; i<5; i++) {

	add	DWORD PTR tv881[ebp], 8
	inc	edi
	cmp	edi, 5
	jb	SHORT $LL18@k1600_perm

; 81   :       }
; 82   :     }
; 83   :     // Rho Pi
; 84   :     t = st[1];

	mov	eax, DWORD PTR [ebx+12]
	mov	edi, DWORD PTR [ebx+8]
	mov	DWORD PTR _t$[ebp+4], eax

; 85   :     for (i=0, r=0; i<24; i++) {

	xor	eax, eax
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN12@k1600_perm
$LL43@k1600_perm:
	mov	eax, DWORD PTR _r$[ebp]
$LN12@k1600_perm:

; 86   :       r += i + 1;

	mov	edx, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1]

; 87   :       j = keccakf_piln[i];

	movzx	eax, BYTE PTR _keccakf_piln$[ebp+edx]

; 88   :       bc[0] = st[j];
; 89   :       st[j] = ROTL64(t, r & 63);

	mov	edx, DWORD PTR _t$[ebp+4]
	lea	esi, DWORD PTR [ebx+eax*8]
	mov	eax, DWORD PTR [esi]
	mov	ebx, ecx
	mov	DWORD PTR _bc$[ebp], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _r$[ebp], ecx
	push	64					; 00000040H
	pop	ecx
	mov	DWORD PTR _bc$[ebp+4], eax
	and	ebx, 63					; 0000003fH
	sub	ecx, ebx
	mov	eax, edi
	call	__aullshr
	mov	DWORD PTR tv1185[ebp], edx
	mov	edx, DWORD PTR _t$[ebp+4]
	mov	DWORD PTR tv1187[ebp], eax
	mov	eax, edi
	mov	ecx, ebx
	call	__allshl
	mov	ecx, DWORD PTR tv1187[ebp]

; 90   :       t = bc[0];

	mov	edi, DWORD PTR _bc$[ebp]

; 91   :     }
; 92   :     // Chi
; 93   :     for (j=0; j<25; j+=5) {

	mov	ebx, DWORD PTR _state$[ebp]
	or	ecx, eax
	mov	eax, DWORD PTR tv1185[ebp]
	or	eax, edx
	inc	DWORD PTR _i$[ebp]
	cmp	DWORD PTR _i$[ebp], 24			; 00000018H
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR _bc$[ebp+4]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR _t$[ebp+4], eax
	jb	SHORT $LL43@k1600_perm
	mov	eax, ebx
	mov	DWORD PTR tv1236[ebp], 5
$LL9@k1600_perm:

; 94   :       for (i=0; i<5; i++) {
; 95   :         bc[i] = st[j + i];

	push	10					; 0000000aH
	pop	ecx
	mov	esi, eax
	lea	edi, DWORD PTR _bc$[ebp]
	rep movsd

; 96   :       }
; 97   :       for (i=0; i<5; i++) {

	xor	esi, esi
$LL3@k1600_perm:

; 98   :         st[j + i] ^= (~bc[keccakf_mod5[(i + 1)]]) & bc[keccakf_mod5[(i + 2)]];

	movzx	ecx, BYTE PTR _keccakf_mod5$[ebp+esi+1]
	mov	edx, DWORD PTR _bc$[ebp+ecx*8]
	mov	edi, DWORD PTR _bc$[ebp+ecx*8+4]
	movzx	ecx, BYTE PTR _keccakf_mod5$[ebp+esi+2]
	not	edx
	and	edx, DWORD PTR _bc$[ebp+ecx*8]
	not	edi
	and	edi, DWORD PTR _bc$[ebp+ecx*8+4]
	xor	DWORD PTR [eax], edx
	xor	DWORD PTR [eax+4], edi
	inc	esi
	add	eax, 8
	cmp	esi, 5
	jb	SHORT $LL3@k1600_perm

; 91   :     }
; 92   :     // Chi
; 93   :     for (j=0; j<25; j+=5) {

	dec	DWORD PTR tv1236[ebp]
	jne	SHORT $LL9@k1600_perm

; 99   :       }
; 100  :     }
; 101  :     // Iota
; 102  :     st[0] ^= rc(&lfsr);

	lea	eax, DWORD PTR _lfsr$[ebp]
	push	eax
	call	_rc
	xor	DWORD PTR [ebx], eax
	xor	DWORD PTR [ebx+4], edx
	dec	DWORD PTR tv1283[ebp]
	pop	ecx
	jne	$LL24@k1600_perm
	pop	edi
	pop	esi
	pop	ebx

; 103  :   }
; 104  : }

	leave
	ret	0
_k1600_permute ENDP
_TEXT	ENDS
END
