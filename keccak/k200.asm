; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\hub\sha3\k200.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_k200_permute
; Function compile flags: /Ogspy
; File c:\hub\sha3\k200.c
;	COMDAT _k200_permute
_TEXT	SEGMENT
_keccakf_piln$ = -64					; size = 24
_rc$ = -40						; size = 18
_bc$ = -20						; size = 5
tv1096 = -12						; size = 4
tv1026 = -8						; size = 4
_rnd$ = -4						; size = 4
tv903 = 8						; size = 4
tv734 = 8						; size = 4
_state$ = 8						; size = 4
_k200_permute PROC					; COMDAT

; 33   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 34   :   int     i, j, rnd, r;
; 35   :   uint8_t t, bc[5];
; 36   :   uint8_t *st = (uint8_t*)state;
; 37   :   
; 38   : uint8_t rc[]={
; 39   :   0x01,0x82,0x8a,0x00,0x8b,0x01,0x81,0x09,0x8a,
; 40   :   0x88,0x09,0x0a,0x8b,0x8b,0x89,0x03,0x02,0x80};
; 41   :   
; 42   : const uint8_t keccakf_piln[24] = 
; 43   : { 10, 7,  11, 17, 18, 3, 5,  16, 8,  21, 24, 4, 
; 44   :   15, 23, 19, 13, 12, 2, 20, 14, 22, 9,  6,  1  };
; 45   :   
; 46   :   for (rnd=0; rnd<18; rnd++) 

	and	DWORD PTR _rnd$[ebp], 0
	push	ebx
	mov	ebx, DWORD PTR _state$[ebp]
	push	esi
	push	edi
	mov	DWORD PTR _rc$[ebp], 9077249		; 008a8201H
	mov	DWORD PTR _rc$[ebp+4], 159449483	; 0981018bH
	mov	DWORD PTR _rc$[ebp+8], 168396938	; 0a09888aH
	mov	DWORD PTR _rc$[ebp+12], 59345803	; 03898b8bH
	mov	WORD PTR _rc$[ebp+16], 32770		; 00008002H
	mov	DWORD PTR _keccakf_piln$[ebp], 285935370 ; 110b070aH
	mov	DWORD PTR _keccakf_piln$[ebp+4], 268763922 ; 10050312H
	mov	DWORD PTR _keccakf_piln$[ebp+8], 68687112 ; 04181508H
	mov	DWORD PTR _keccakf_piln$[ebp+12], 219354895 ; 0d13170fH
	mov	DWORD PTR _keccakf_piln$[ebp+16], 236192268 ; 0e14020cH
	mov	DWORD PTR _keccakf_piln$[ebp+20], 17172758 ; 01060916H
$LL43@k200_permu:

; 47   :   {
; 48   :     // Theta
; 49   :     for (i=0; i<5; i++) {     

	push	5
	pop	edi
	lea	esi, DWORD PTR _bc$[ebp]
	lea	eax, DWORD PTR [ebx+15]
	mov	ecx, edi
$LL21@k200_permu:

; 50   :       bc[i] = st[i] 
; 51   :             ^ st[i +  5] 
; 52   :             ^ st[i + 10] 
; 53   :             ^ st[i + 15] 
; 54   :             ^ st[i + 20];

	mov	dl, BYTE PTR [eax-15]
	xor	dl, BYTE PTR [eax-10]
	xor	dl, BYTE PTR [eax-5]
	xor	dl, BYTE PTR [eax+5]
	xor	dl, BYTE PTR [eax]
	inc	eax
	mov	BYTE PTR [esi], dl
	inc	esi
	dec	ecx
	jne	SHORT $LL21@k200_permu

; 55   :     }
; 56   :     for (i=0; i<5; i++) {

	push	4
	pop	esi
	mov	DWORD PTR tv734[ebp], edi
$LL18@k200_permu:

; 57   :       t = bc[(i + 4) % 5] ^ ROTL8(bc[(i + 1) % 5], 1);

	lea	eax, DWORD PTR [esi-3]
	cdq
	idiv	edi
	mov	eax, esi
	push	5
	pop	edi
	mov	cl, BYTE PTR _bc$[ebp+edx]
	cdq
	idiv	edi
	rol	cl, 1
	lea	eax, DWORD PTR [ebx+esi-4]
	xor	cl, BYTE PTR _bc$[ebp+edx]
	mov	edx, edi
$LL15@k200_permu:

; 58   :       for (j=0; j<25; j+=5) {
; 59   :         st[j + i] ^= t;

	xor	BYTE PTR [eax], cl
	add	eax, edi
	dec	edx
	jne	SHORT $LL15@k200_permu

; 55   :     }
; 56   :     for (i=0; i<5; i++) {

	inc	esi
	dec	DWORD PTR tv734[ebp]
	jne	SHORT $LL18@k200_permu

; 60   :       }
; 61   :     }
; 62   :     // Rho Pi
; 63   :     t = st[1];

	mov	dl, BYTE PTR [ebx+1]

; 64   :     for (i=0, r=0; i<24; i++) {

	xor	edi, edi
	xor	eax, eax
$LL12@k200_permu:

; 65   :       r += i + 1;
; 66   :       j = keccakf_piln[i];

	movzx	esi, BYTE PTR _keccakf_piln$[ebp+edi]

; 67   :       bc[0] = st[j];

	mov	cl, BYTE PTR [esi+ebx]
	lea	eax, DWORD PTR [eax+edi+1]
	mov	BYTE PTR _bc$[ebp], cl

; 68   :       st[j] = ROTL8(t, r & 7);

	mov	ecx, eax
	and	ecx, 7
	rol	dl, cl
	inc	edi
	mov	BYTE PTR [esi+ebx], dl

; 69   :       t = bc[0];

	mov	dl, BYTE PTR _bc$[ebp]
	cmp	edi, 24					; 00000018H
	jl	SHORT $LL12@k200_permu

; 70   :     }
; 71   :     // Chi
; 72   :     for (j=0; j<25; j+=5) {

	mov	eax, ebx
	mov	DWORD PTR tv1096[ebp], 5
$LL9@k200_permu:

; 73   :       for (i=0; i<5; i++) {
; 74   :         bc[i] = st[j + i];

	mov	esi, eax
	lea	edi, DWORD PTR _bc$[ebp]
	movsd
	movsb

; 75   :       }
; 76   :       for (i=0; i<5; i++) {

	mov	DWORD PTR tv903[ebp], 2
	mov	esi, eax
	mov	DWORD PTR tv1026[ebp], 5
$LL44@k200_permu:

; 77   :         st[j + i] ^= (~bc[(i + 1) % 5]) & bc[(i + 2) % 5];

	mov	edi, DWORD PTR tv903[ebp]
	lea	eax, DWORD PTR [edi-1]
	cdq
	push	5
	pop	ecx
	idiv	ecx
	mov	eax, edi
	push	5
	pop	edi
	mov	cl, BYTE PTR _bc$[ebp+edx]
	cdq
	idiv	edi
	not	cl
	and	cl, BYTE PTR _bc$[ebp+edx]
	xor	BYTE PTR [esi], cl
	inc	DWORD PTR tv903[ebp]
	inc	esi
	dec	DWORD PTR tv1026[ebp]
	jne	SHORT $LL44@k200_permu

; 70   :     }
; 71   :     // Chi
; 72   :     for (j=0; j<25; j+=5) {

	dec	DWORD PTR tv1096[ebp]
	mov	eax, esi
	jne	SHORT $LL9@k200_permu

; 78   :       }
; 79   :     }
; 80   :     // Iota
; 81   :     st[0] ^= rc[rnd];

	mov	eax, DWORD PTR _rnd$[ebp]
	mov	al, BYTE PTR _rc$[ebp+eax]
	xor	BYTE PTR [ebx], al
	inc	DWORD PTR _rnd$[ebp]
	cmp	DWORD PTR _rnd$[ebp], 18		; 00000012H
	jl	$LL43@k200_permu
	pop	edi
	pop	esi
	pop	ebx

; 82   :   }
; 83   : }

	leave
	ret	0
_k200_permute ENDP
_TEXT	ENDS
END
