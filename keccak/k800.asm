; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	c:\hub\sha3\keccak\k800.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_k800_permute
PUBLIC	_rcx
; Function compile flags: /Ogspy
; File c:\hub\sha3\keccak\k800.c
;	COMDAT _rcx
_TEXT	SEGMENT
_LFSR$ = 8						; size = 4
_rcx	PROC						; COMDAT

; 60   :   __asm {
; 61   :     pushad

	pushad

; 62   :     xor    eax, eax            ; eax = 0

	xor	eax, eax

; 63   :     cdq

	cdq

; 64   :     xchg   eax, ebx            ; c = 0

	xchg	eax, ebx

; 65   :     inc    edx                 ; i = 1    

	inc	edx

; 66   :     mov    esi, [esp+32+4]     ; esi = &LFSR

	mov	esi, DWORD PTR [esp+36]

; 67   :     mov    edi, esi            ; edi = &LFSR

	mov	edi, esi

; 68   :     lodsb                      ; al = t = *LFSR

	lodsb
$rc_l0$4:

; 69   : rc_l0:    
; 70   :     test   al, 1               ; t & 1

	test	al, 1

; 71   :     je     rc_l1    

	je	SHORT $rc_l1$5

; 72   :     lea    ecx, [edx-1]        ; ecx = (i - 1)

	lea	ecx, DWORD PTR [edx-1]

; 73   :     cmp    cl, 32              ; skip if (ecx >= 32)

	cmp	cl, 32					; 00000020H

; 74   :     jae    rc_l1    

	jae	SHORT $rc_l1$5

; 75   :     btc    ebx, ecx            ; c ^= 1UL << (i - 1)

	btc	ebx, ecx
$rc_l1$5:

; 76   : rc_l1:    
; 77   :     add    al, al              ; t << 1

	add	al, al

; 78   :     sbb    ah, ah              ; ah = (t < 0) ? 0x00 : 0xFF

	sbb	ah, ah

; 79   :     and    ah, 0x71            ; ah = (ah == 0xFF) ? 0x71 : 0x00  

	and	ah, 113					; 00000071H

; 80   :     xor    al, ah  

	xor	al, ah

; 81   :     add    dl, dl              ; i += i

	add	dl, dl

; 82   :     jns    rc_l0               ; while (i != 128)

	jns	SHORT $rc_l0$4

; 83   :     stosb                      ; save t

	stosb

; 84   :     mov    [esp+28], ebx       ; return c & 255

	mov	DWORD PTR [esp+28], ebx

; 85   :     popad

	popad

; 86   :     ret

	ret	0
_rcx	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\sha3\keccak\k800.c
;	COMDAT _k800_permute
_TEXT	SEGMENT
_lfsr$ = -57						; size = 1
_m5$ = -56						; size = 12
_bc$ = -44						; size = 20
_piln$ = -24						; size = 24
tv1316 = 8						; size = 4
_state$ = 8						; size = 4
_k800_permute PROC					; COMDAT

; 91   : {

	sub	esp, 60					; 0000003cH
	push	ebx
	mov	ebx, DWORD PTR _state$[esp+60]
	push	ebp
	push	esi
	push	edi

; 92   :   uint32_t i, j, rnd, r;
; 93   :   uint32_t t, bc[5];
; 94   :   uint8_t  lfsr=1;

	mov	BYTE PTR _lfsr$[esp+76], 1
	lea	eax, DWORD PTR [ebx+60]

; 95   :   uint32_t *st=(uint32_t*)state;
; 96   :   uint8_t  *p, *m;
; 97   :   
; 98   :   uint32_t piln[6]=

	mov	DWORD PTR _piln$[esp+76], 285935370	; 110b070aH
	mov	DWORD PTR _piln$[esp+80], 268763922	; 10050312H
	mov	DWORD PTR _piln$[esp+84], 68687112	; 04181508H
	mov	DWORD PTR _piln$[esp+88], 219354895	; 0d13170fH
	mov	DWORD PTR _piln$[esp+92], 236192268	; 0e14020cH
	mov	DWORD PTR _piln$[esp+96], 17172758	; 01060916H

; 99   :   { 0x110b070a, 0x10050312, 0x04181508, 
; 100  :     0x0d13170f, 0x0e14020c, 0x01060916 };
; 101  : 
; 102  :   uint32_t m5[3]=

	mov	DWORD PTR _m5$[esp+76], 50462976	; 03020100H
	mov	DWORD PTR _m5$[esp+80], 33619972	; 02010004H
	mov	DWORD PTR _m5$[esp+84], 1027		; 00000403H
	mov	DWORD PTR tv1316[esp+72], 22		; 00000016H
$LL4@k800_permu:

; 103  :   { 0x03020100, 0x02010004, 0x00000403 };
; 104  :   
; 105  :   p = (uint8_t*)piln;
; 106  :   m = (uint8_t*)m5;
; 107  :   
; 108  :   for (rnd=0; rnd<22; rnd++) 
; 109  :   {
; 110  :     // Theta
; 111  :     for (i=0; i<5; i++) {     

	xor	edx, edx
	mov	ecx, eax
$LL7@k800_permu:

; 112  :       bc[i] = st[i] 

	mov	eax, DWORD PTR [ecx-60]
	xor	eax, DWORD PTR [ecx-40]
	xor	eax, DWORD PTR [ecx-20]
	xor	eax, DWORD PTR [ecx+20]
	xor	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR _bc$[esp+edx*4+76], eax
	inc	edx
	cmp	edx, 5
	jb	SHORT $LL7@k800_permu

; 113  :             ^ st[i +  5] 
; 114  :             ^ st[i + 10] 
; 115  :             ^ st[i + 15] 
; 116  :             ^ st[i + 20];
; 117  :     }
; 118  :     for (i=0; i<5; i++) {

	xor	ecx, ecx
	mov	edx, ebx
$LL10@k800_permu:

; 119  :       t = bc[m[(i + 4)]] ^ ROTL32(bc[m[(i + 1)]], 1);

	movzx	eax, BYTE PTR _m5$[esp+ecx+77]
	push	5
	pop	edi
	mov	esi, DWORD PTR _bc$[esp+eax*4+76]
	movzx	eax, BYTE PTR _m5$[esp+ecx+80]
	rol	esi, 1
	xor	esi, DWORD PTR _bc$[esp+eax*4+76]
	mov	eax, edx
$LL13@k800_permu:

; 120  :       for (j=0; j<25; j+=5) {
; 121  :         st[j + i] ^= t;

	xor	DWORD PTR [eax], esi
	lea	eax, DWORD PTR [eax+20]
	sub	edi, 1
	jne	SHORT $LL13@k800_permu

; 113  :             ^ st[i +  5] 
; 114  :             ^ st[i + 10] 
; 115  :             ^ st[i + 15] 
; 116  :             ^ st[i + 20];
; 117  :     }
; 118  :     for (i=0; i<5; i++) {

	inc	ecx
	add	edx, 4
	cmp	ecx, 5
	jb	SHORT $LL10@k800_permu

; 122  :       }
; 123  :     }
; 124  :     // Rho Pi
; 125  :     t = st[1];

	mov	edi, DWORD PTR [ebx+4]

; 126  :     for (i=0, r=0; i<24; i++) {

	xor	ebp, ebp
	xor	esi, esi
$LL16@k800_permu:

; 127  :       r += i + 1;
; 128  :       j = p[i];

	movzx	edx, BYTE PTR _piln$[esp+esi+76]
	inc	ebp
	add	ebp, esi

; 129  :       bc[0] = st[j];
; 130  :       st[j] = ROTL32(t, r & 31);

	mov	ecx, ebp
	and	ecx, 31					; 0000001fH
	mov	eax, DWORD PTR [ebx+edx*4]
	rol	edi, cl
	inc	esi
	mov	DWORD PTR [ebx+edx*4], edi

; 131  :       t = bc[0];

	mov	edi, eax
	mov	DWORD PTR _bc$[esp+76], eax
	cmp	esi, 24					; 00000018H
	jb	SHORT $LL16@k800_permu

; 132  :     }
; 133  :     // Chi
; 134  :     for (j=0; j<25; j+=5) {

	push	5
	mov	edx, ebx
	pop	ebp
$LL19@k800_permu:

; 135  :       for (i=0; i<5; i++) {
; 136  :         bc[i] = st[j + i];

	push	5
	pop	ecx
	mov	esi, edx
	lea	edi, DWORD PTR _bc$[esp+76]
	rep movsd

; 137  :       }
; 138  :       for (i=0; i<5; i++) {

	xor	esi, esi
$LL25@k800_permu:

; 139  :         st[j + i] ^= (~bc[m[(i + 1)]]) & bc[m[(i + 2)]];

	movzx	eax, BYTE PTR _m5$[esp+esi+77]
	mov	ecx, DWORD PTR _bc$[esp+eax*4+76]
	movzx	eax, BYTE PTR _m5$[esp+esi+78]
	not	ecx
	and	ecx, DWORD PTR _bc$[esp+eax*4+76]
	xor	DWORD PTR [edx], ecx
	inc	esi
	add	edx, 4
	cmp	esi, 5
	jb	SHORT $LL25@k800_permu

; 132  :     }
; 133  :     // Chi
; 134  :     for (j=0; j<25; j+=5) {

	sub	ebp, 1
	jne	SHORT $LL19@k800_permu

; 140  :       }
; 141  :     }
; 142  :     // Iota
; 143  :     st[0] ^= rcx(&lfsr);

	lea	eax, DWORD PTR _lfsr$[esp+76]
	push	eax
	call	_rcx
	xor	DWORD PTR [ebx], eax
	lea	eax, DWORD PTR [ebx+60]
	sub	DWORD PTR tv1316[esp+76], 1
	pop	ecx
	jne	$LL4@k800_permu
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 144  :   }
; 145  : }

	add	esp, 60					; 0000003cH
	ret	0
_k800_permute ENDP
_TEXT	ENDS
END
