; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	c:\hub\sha3\keccak\k800.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_k800_permute
PUBLIC	_rc
; Function compile flags: /Ogspy
; File c:\hub\sha3\keccak\k800.c
;	COMDAT _rc
_TEXT	SEGMENT
_LFSR$ = 8						; size = 4
_rc	PROC						; COMDAT

; 35   : {

	push	ebx
	push	esi
	push	edi

; 36   :   uint32_t c; 
; 37   :   int8_t   t;
; 38   :   uint8_t  i;
; 39   : 
; 40   :   c = 0;
; 41   :   t = *LFSR;

	mov	edi, DWORD PTR _LFSR$[esp+8]
	xor	esi, esi

; 42   :   
; 43   :   for (i=1; i<128; i += i) 

	mov	bh, 1
	mov	bl, BYTE PTR [edi]
$LL4@rc:

; 44   :   {
; 45   :     if (t & 1) {

	test	bl, 1
	je	SHORT $LN6@rc

; 46   :       // if shift value is < 32
; 47   :       if ((i-1) < 32) {

	movzx	eax, bh
	cmp	eax, 33					; 00000021H
	jae	SHORT $LN6@rc

; 48   :         c ^= 1UL << (i - 1);

	dec	eax
	btc	esi, eax
$LN6@rc:

; 49   :       }
; 50   :     }
; 51   :     t = (t & 0x80) ? (t << 1) ^ 0x71 : t << 1;

	mov	cl, bl
	add	cl, cl
	mov	al, cl
	movzx	edx, cl
	xor	al, 113					; 00000071H
	test	bl, bl
	movzx	ecx, al
	cmovs	edx, ecx
	add	bh, bh
	mov	bl, dl
	cmp	bh, 128					; 00000080H
	jb	SHORT $LL4@rc

; 52   :   }
; 53   :   *LFSR = (uint8_t)t;

	mov	BYTE PTR [edi], bl

; 54   :   return c;

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 55   : }

	ret	0
_rc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\hub\sha3\keccak\k800.c
;	COMDAT _k800_permute
_TEXT	SEGMENT
_lfsr$ = -57						; size = 1
_m5$ = -56						; size = 12
_bc$ = -44						; size = 20
_piln$ = -24						; size = 24
tv1243 = 8						; size = 4
_state$ = 8						; size = 4
_k800_permute PROC					; COMDAT

; 57   : void k800_permute (void *state) {

	sub	esp, 60					; 0000003cH
	push	ebx
	mov	ebx, DWORD PTR _state$[esp+60]
	push	ebp
	push	esi
	push	edi

; 58   :   uint32_t i, j, rnd, r, t, u, bc[5];
; 59   :   uint8_t  lfsr=1;

	mov	BYTE PTR _lfsr$[esp+76], 1
	lea	eax, DWORD PTR [ebx+60]

; 60   :   uint32_t *st=(uint32_t*)state;
; 61   :   uint8_t  *p, *m;
; 62   :   
; 63   :   uint32_t piln[6]=

	mov	DWORD PTR _piln$[esp+76], 285935370	; 110b070aH
	mov	DWORD PTR _piln$[esp+80], 268763922	; 10050312H
	mov	DWORD PTR _piln$[esp+84], 68687112	; 04181508H
	mov	DWORD PTR _piln$[esp+88], 219354895	; 0d13170fH
	mov	DWORD PTR _piln$[esp+92], 236192268	; 0e14020cH
	mov	DWORD PTR _piln$[esp+96], 17172758	; 01060916H

; 64   :   { 0x110b070a, 0x10050312, 0x04181508, 
; 65   :     0x0d13170f, 0x0e14020c, 0x01060916 };
; 66   : 
; 67   :   uint32_t m5[3]=

	mov	DWORD PTR _m5$[esp+76], 50462976	; 03020100H
	mov	DWORD PTR _m5$[esp+80], 33619972	; 02010004H
	mov	DWORD PTR _m5$[esp+84], 1027		; 00000403H
	mov	DWORD PTR tv1243[esp+72], 22		; 00000016H
$LL4@k800_permu:

; 68   :   { 0x03020100, 0x02010004, 0x00000403 };
; 69   :   
; 70   :   p = (uint8_t*)piln;
; 71   :   m = (uint8_t*)m5;
; 72   :   
; 73   :   for (rnd=0; rnd<22; rnd++) {
; 74   :     // Theta
; 75   :     for (i=0; i<5; i++) {     

	xor	edx, edx
	mov	ecx, eax
$LL7@k800_permu:

; 76   :       t  = st[i]; 
; 77   :       t ^= st[i +  5]; 
; 78   :       t ^= st[i + 10]; 
; 79   :       t ^= st[i + 15]; 
; 80   :       t ^= st[i + 20];

	mov	eax, DWORD PTR [ecx-60]
	xor	eax, DWORD PTR [ecx-40]
	xor	eax, DWORD PTR [ecx-20]
	xor	eax, DWORD PTR [ecx+20]
	xor	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+4]

; 81   :       bc[i] = t;

	mov	DWORD PTR _bc$[esp+edx*4+76], eax
	inc	edx
	cmp	edx, 5
	jb	SHORT $LL7@k800_permu

; 82   :     }
; 83   :     for (i=0; i<5; i++) {

	xor	ecx, ecx
	mov	edx, ebx
$LL10@k800_permu:

; 84   :       t  = bc[m[(i + 4)]]; 
; 85   :       t ^= ROTL32(bc[m[(i + 1)]], 1);

	movzx	eax, BYTE PTR _m5$[esp+ecx+77]
	push	5
	pop	edi
	mov	esi, DWORD PTR _bc$[esp+eax*4+76]
	movzx	eax, BYTE PTR _m5$[esp+ecx+80]
	rol	esi, 1
	xor	esi, DWORD PTR _bc$[esp+eax*4+76]
	mov	eax, edx
$LL13@k800_permu:

; 86   :       for (j=0; j<25; j+=5) {
; 87   :         st[i+j] ^= t;

	xor	DWORD PTR [eax], esi
	lea	eax, DWORD PTR [eax+20]
	sub	edi, 1
	jne	SHORT $LL13@k800_permu

; 82   :     }
; 83   :     for (i=0; i<5; i++) {

	inc	ecx
	add	edx, 4
	cmp	ecx, 5
	jb	SHORT $LL10@k800_permu

; 88   :       }
; 89   :     }
; 90   :     // Rho Pi
; 91   :     u = st[1];

	mov	edi, DWORD PTR [ebx+4]

; 92   :     for (i=0, r=0; i<24; i++) {

	xor	ecx, ecx
	xor	esi, esi
$LL16@k800_permu:

; 93   :       r += i + 1;       
; 94   :       u  = ROTL32(u, r);
; 95   :       XCHG(st[p[i]], u);

	movzx	edx, BYTE PTR _piln$[esp+esi+76]
	inc	ecx
	add	ecx, esi
	rol	edi, cl
	inc	esi
	mov	eax, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [ebx+edx*4], edi
	mov	edi, eax
	cmp	esi, 24					; 00000018H
	jb	SHORT $LL16@k800_permu

; 96   :       bc[0] = u;
; 97   :     }
; 98   :     // Chi
; 99   :     for (j=0; j<25; j+=5) {

	push	5
	mov	edx, ebx
	pop	ebp
$LL19@k800_permu:

; 100  :       memcpy(&bc, &st[j], 5*4);      

	push	5
	pop	ecx
	mov	esi, edx
	lea	edi, DWORD PTR _bc$[esp+76]
	rep movsd

; 101  :       for (i=0; i<5; i++) {

	xor	esi, esi
$LL22@k800_permu:

; 102  :         t  = ~bc[m[(i + 1)]];

	movzx	eax, BYTE PTR _m5$[esp+esi+77]
	mov	ecx, DWORD PTR _bc$[esp+eax*4+76]

; 103  :         t &=  bc[m[(i + 2)]];        

	movzx	eax, BYTE PTR _m5$[esp+esi+78]
	not	ecx
	and	ecx, DWORD PTR _bc$[esp+eax*4+76]

; 104  :         st[j + i] ^= t;

	xor	DWORD PTR [edx], ecx
	inc	esi
	add	edx, 4
	cmp	esi, 5
	jb	SHORT $LL22@k800_permu

; 96   :       bc[0] = u;
; 97   :     }
; 98   :     // Chi
; 99   :     for (j=0; j<25; j+=5) {

	sub	ebp, 1
	jne	SHORT $LL19@k800_permu

; 105  :       }
; 106  :     }
; 107  :     // Iota
; 108  :     st[0] ^= rc(&lfsr);

	lea	eax, DWORD PTR _lfsr$[esp+76]
	push	eax
	call	_rc
	xor	DWORD PTR [ebx], eax
	lea	eax, DWORD PTR [ebx+60]
	sub	DWORD PTR tv1243[esp+76], 1
	pop	ecx
	jne	$LL4@k800_permu
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 109  :   }
; 110  : }

	add	esp, 60					; 0000003cH
	ret	0
_k800_permute ENDP
_TEXT	ENDS
END
